<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Archery Game</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#87CEEB; }
    #hud {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      font-family: sans-serif; background: rgba(255,255,255,0.8);
      padding: 10px; border-radius: 8px;
    }
    #score { font-weight: bold; }
  </style>
</head>
<body>
<div id="hud">
  <div>Wind: <span id="wind"></span></div>
  <div>Score: <span id="score">0</span></div>
  <div>Click and drag to aim, release to shoot.</div>
</div>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Light
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
let dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(5,10,7);
scene.add(dirLight);

// Ground
let ground = new THREE.Mesh(
  new THREE.PlaneGeometry(100,100),
  new THREE.MeshLambertMaterial({color:0x228B22})
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Target
let target = new THREE.Mesh(
  new THREE.CylinderGeometry(2,2,0.2,32),
  new THREE.MeshBasicMaterial({color:0xffffff})
);
target.position.set(0,2,-50);
target.rotation.x = Math.PI/2;
scene.add(target);

// Bullseye
let bullseye = new THREE.Mesh(
  new THREE.CircleGeometry(0.5,32),
  new THREE.MeshBasicMaterial({color:0xff0000})
);
bullseye.position.set(0,2.01,-50);
bullseye.rotation.x = -Math.PI/2;
scene.add(bullseye);

// Bow position
camera.position.set(0,2,0);
let controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.maxPolarAngle = Math.PI/2;

// Wind
let windStrength = 0;
let windDirection = 0;
function randomWind() {
  windStrength = (Math.random()*2 - 1) * 2; // m/s
  windDirection = Math.random() * 2 * Math.PI;
  let dirText = ((windDirection*180/Math.PI) | 0) + "Â°";
  document.getElementById('wind').textContent = `${windStrength.toFixed(1)} m/s @ ${dirText}`;
}
randomWind();

// Shooting
let arrows = [];
let score = 0;
let isDrawing = false;
let drawStart = 0;

renderer.domElement.addEventListener('mousedown', () => {
  isDrawing = true;
  drawStart = performance.now();
});
renderer.domElement.addEventListener('mouseup', () => {
  if (!isDrawing) return;
  isDrawing = false;
  let drawPower = Math.min((performance.now() - drawStart) / 1000, 2); // max 2s
  shootArrow(drawPower * 50);
});

function shootArrow(speed) {
  let arrow = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05,0.05,2),
    new THREE.MeshBasicMaterial({color:0x8B4513})
  );
  arrow.rotation.z = Math.PI/2;
  arrow.position.set(camera.position.x, camera.position.y, camera.position.z);
  let dir = new THREE.Vector3(0,0,-1);
  dir.applyQuaternion(camera.quaternion).normalize();
  arrow.userData = {
    velocity: dir.multiplyScalar(speed),
    alive: true
  };
  arrows.push(arrow);
  scene.add(arrow);
  randomWind();
}

function animate() {
  requestAnimationFrame(animate);
  let delta = 0.016;

  arrows.forEach(arrow => {
    if (!arrow.userData.alive) return;
    // wind effect
    let windVec = new THREE.Vector3(Math.cos(windDirection), 0, Math.sin(windDirection)).multiplyScalar(windStrength);
    arrow.userData.velocity.add(windVec.clone().multiplyScalar(delta));
    arrow.position.add(arrow.userData.velocity.clone().multiplyScalar(delta));

    // gravity
    arrow.userData.velocity.y -= 9.8 * delta;

    // check hit (simple bounding check)
    const onPlaneZ = Math.abs(arrow.position.z - target.position.z) < 0.5;
    const yOk = Math.abs(arrow.position.y - 2) < 1.2; // target height window
    const xOk = Math.abs(arrow.position.x - target.position.x) < 2.0; // target radius window
    if (onPlaneZ && yOk && xOk) {
      arrow.userData.alive = false;
      // bullseye proximity
      let dist = arrow.position.distanceTo(bullseye.position);
      if (dist < 0.5) score += 10;
      else score += 5;
      document.getElementById('score').textContent = score;
    }
  });

  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
